# 浏览器获取到服务端资源后

- 解析 HTML 资源生成 DOM 树

  1. 浏览器接收到的是二进制的字节数据，浏览器会将这些二进制的数据转换成字符串
  2. 对字符串进行词法分析

- 解析 css 资源生成 CSSOM 树
- 合并 DOM 树和 CSS 树，生成 render 树
  1. 只会包含需要显示的节点
  2. 根据渲染树来布局页面（回流）
  3. GPU 绘制，合成图层，显示在页面上。（重绘）

# 回流

    修改一个元素的几何属性会导致回流，
    1. 修改宽高
    2. 页面初次渲染
    3. 添加，删除元素
    4. 改变窗口大小

# 重绘

外观发生改变
字体大小，
颜色

# 浏览器的优化策略

    当我们修改一个元素的几何属性导致浏览器需要回流时，浏览器会维护一个渲染队列，将需要回流的操作存入队列中，等到后续没有回流行为或者达到阈值时，会一次性将队列中的行为全部执行。

offsetxxx
clientxxx
会导致渲染队列强制刷新

优化重排和重绘可以提高页面的性能：

减少重排：避免在动画中频繁修改元素的样式，使用 CSS3 动画或 transform 属性可以优化动画效果。
合并重排和重绘：使用 requestAnimationFrame（RAF）等方法将多次重排合并为一次，减少性能损耗。
使用 GPU 加速：某些属性如 transform、opacity 等可以利用 GPU 加速，减少重排和重绘的消耗。
优化 DOM 操作：减少不必要的 DOM 操作和频繁的 DOM 操作，尽量一次性修改多个样式，减少重排和重绘的触发次数。

# 强缓存

- 设置响应头
  Cache-control:'max-age=多少秒'

- 通过浏览器 url 地址栏发送的 get 请求，无法被强缓存

- 后端资源修改了，前端无法实时拿到最新资源（通常文件名都携带一串 hash 值，只要资源被修改，hash 值就改变了，也就是文件名被修改了，那么浏览器一定会重新请求。）

# 协商缓存

- 设置响应头
  Last-Modified: stats.mtimeMs //时间戳

浏览器就会自动在请求头中携带 if-modified-since,且值为响应头返回的值，当后端判断前端携带

浏览器的缓存机制主要分为强缓存和协商缓存，它们可以帮助减少网络请求，加快页面加载速度，并减轻服务器的负载。

# 强缓存：

强缓存是指浏览器在请求资源时，先检查本地缓存是否存在有效的缓存副本，如果存在且未过期，则直接使用缓存副本，不会向服务器发送请求。
强缓存通过设置 HTTP 响应头来实现，常见的头部字段有：
Cache-Control：通过设置 max-age 指令来定义资源的有效期，单位为秒。
浏览器在发起请求前会先检查缓存的有效期，如果缓存尚未过期，则直接从缓存中获取资源，不会发起网络请求。

# 协商缓存：

当资源的强缓存失效时，浏览器会向服务器发送请求，服务器会根据请求头中的一些字段来判断资源是否发生了变化。
如果资源未发生变化，则服务器返回 304 Not Modified 状态码，并在响应头中包含一些信息，告诉浏览器可以使用强缓存。
协商缓存的实现依赖于以下几个头部字段：
Last-Modified：指定资源的最后修改时间。
ETag：资源的唯一标识符，通常是资源内容的哈希值或者其他生成的唯一字符串。(请求时会携带上次请求生成的 ETag 和服务器的对比，相同则返回 304)
当浏览器再次请求资源时，会在请求头中带上 If-Modified-Since 或 If-None-Match 字段，告诉服务器上次请求的资源是什么时候或者是什么标识符。
服务器收到请求后，根据这些字段来判断资源是否发生了变化，如果未发生变化，则返回 304 状态码，告知浏览器直接使用本地缓存。

# 强缓存失效

强缓存可能会失效的原因主要包括以下几点：

缓存过期时间到期: 强缓存是通过设置资源的过期时间或最大缓存时间来控制的。当资源的过期时间到期或者超过了最大缓存时间，浏览器会认为缓存已经失效，需要重新向服务器发起请求获取最新的资源。

用户手动刷新页面: 当用户手动刷新页面时，浏览器会忽略强缓存，而直接向服务器请求最新的资源，以确保用户能够获取到最新的内容。

清除浏览器缓存: 如果用户手动清除了浏览器的缓存数据，或者通过浏览器设置将缓存清除，那么之前存储的所有缓存都会被清除，导致强缓存失效。

特定的缓存控制头: 有时服务器可能发送一些特定的缓存控制头，如 Cache-Control: no-cache 或 Cache-Control: no-store，这些头会指示浏览器不要使用强缓存，而直接向服务器请求资源。

资源被修改: 如果服务器端的资源发生了变化，比如内容更新或者被删除重建，那么强缓存也会失效。服务器会发送新的缓存控制头，告诉浏览器需要重新获取资源。

# 15.浏览器垃圾回收机制

1. 手动回收
2. 自动回收

## 代际假说

1.  大部分的对象在内存中存在的时间是很短的
2.  不死的对象，会活得更久
3.

## 分代收集

- 标记-清除：这是最常见的垃圾回收算法之一。它通过标记所有活跃对象，然后清除未标记的对象来进行垃圾回收。这个过程会导致一些停顿，因为在标记和清除阶段，浏览器可能需要暂停页面的执行。(整理内存)
  递归一个对象，当所有的属性都不被使用就认为是垃圾数据。

- 引用计数：这种方法通过记录每个对象被引用的次数来进行垃圾回收。当一个对象的引用次数变为零时，就可以被回收。然而，引用计数法难以处理循环引用的情况，并且可能导致内存泄漏。

- 标记-整理：这种算法首先标记所有活跃对象，然后将它们向一端移动，清理掉另一端的垃圾对象，从而实现内存空间的整理和压缩。

- 增量式垃圾回收：这种方法将整个垃圾回收过程分解成多个小步骤，每一步都会执行一部分垃圾回收工作，从而减少单次回收所带来的停顿时间。

# 16.v8

- 堆被分为新生代区和老生代区

  - 新生代区：副垃圾回收器
  - 老生代区：主垃圾回收器

- 垃圾回收器的工作流程：（联想清理堆）

1. 标记空间中的活动对象和非活动对象（活动对象：还在使用的对象。非活动对象：要被回收的对象）
2. 回收非活动对象的空间
3. 整理内存碎片。

- 副垃圾回收器：
  将新生代分成对象空间和空闲空间。对象空间用于存放新进的小对象，当存满后执行回收处理，再将存活的对象复制到空闲空间，此时就做好了内存整理，再反转对象空间和空闲空间。新对象空间继续接收对象（两次回收仍存活的对象会晋升到老生代区）
- 主垃圾回收器
  因为存放的对象都比较大，所以不适合用副垃圾回收器相同的的算法，只能采用标记清除法，递归一个对象，当对象中任何一个属性都没被使用，则作为垃圾回收掉，再整理空间。

## 什么时候进行垃圾回收？

- 周期性的进行
- 内存占满
- 函数执行完成且函数作用域变量没被引用
- 页面卸载

## 与作用域相关

- 全局作用域在整个生命周期内存在，不会被回收
- 函数作用域函数执行完成且函数作用域变量没被引用
- 块级作用域执行结束

## 全停顿

- js 运行在 v8 的主线程上，当垃圾回收机制生效时，js 的执行要让出线程，那么 js 执行就会暂停
- 采用增量标记法来将垃圾回收过程中的标记过程分成很多个小任务，和 js 执行来回切换执行。

# js 与 html

js 会阻塞 html 的解析和渲染，解析完成等待 js 执行再渲染。

阻塞渲染：如果 JavaScript 代码位于 <script> 标签中，并且位于 HTML 页面的 <head> 部分或者在页面内容中的任何位置，浏览器会在执行 JavaScript 代码之前停止解析 HTML，并等待 JavaScript 代码执行完成后再继续解析和渲染页面。这会导致页面的渲染被延迟，直到 JavaScript 代码执行完毕。

非阻塞渲染：为了避免 JavaScript 代码阻塞页面渲染，可以采取一些措施，例如将 JavaScript 代码放在 HTML 页面的底部，或者使用异步加载 JavaScript 的方式（例如使用 <script async> 或者通过 JavaScript 异步加载技术）。这样浏览器在加载和解析 HTML 页面时不会因为 JavaScript 而停止，可以继续渲染页面的其余部分，同时 JavaScript 代码在后台加载和执行。

# js 加载执行会阻塞 html 的渲染

1. 在 script 标签上加 async，该 js 加载就不会阻塞 html 的解析渲染，加载完开始执行 js 还是会阻止解析和渲染。
2. 在 script 标签上加 defer，该 js 加载就不会阻塞 html 的解析渲染，提前加载完会等 html 解析完执行 js（页面完全渲染完前，DOMContentLoaded[当浏览器解析 HTML 文档并构建了 DOM 树,图片，样式表加载前] 事件触发前才执行）。

# 浏览器三个存储

共同点：都会受到同源策略的影响，协议：域名：端口 ---- http www(子域名) .baidu.com（主域名）

1. - local 可以同源共享数据(子域名会跨域)，可以使用 postMessage API
   - 5~10MB 大小，电脑不同有差异
   - 受到 xxs 脚本攻击（网站存在恶意脚本代码），不易受到 CSRF
   - 主要用于跟踪用户会话，存储用户偏好设置以及记住登陆状态等功能
2. - session 同源需要同窗口
     分类看问题：
     1）在一个窗口下，多个 iframe 中，是共享；操作互影响;
     注意：iframe 清除，sessionStorage 不会清除，sessionStorage 只会看不到，当页面重新加载后 sessionStorage 会在应用中出现；所以一些 session 会无法保活
     2）在多个窗口下：
     本身 sessionStorage 就是每打开一个新窗口，就有一个自己的 sessionStorage 对象，关闭窗口即 过期当前窗口的 sessionStorage；
     但是通过 A 页面打开的 B 页面（ 如：window.open('同源网址') ），会进行源网页 sessionStorage 复制，并在窗口 B 中可以访问到；
     修改窗口 A 的 sessionStorage，不会对窗口 B 内部的 sessionStorage 影响。
   - 关闭网站标签或浏览器就会清除数据，刷新不会
   - 适合临时存储会话数据，比如临时保存表单数据等。
3. - cookie 不能在不同域名下通信，可以通过设置 cookie 的 domain 和 path 属性为相同来实现
     - domain 的设置对子域生效，如 domain 设置为.a.com，则 b.a.com 和 c.a.com 均可使用该 cookie
     - path 不同，用于设置 cookie 在同一域名的不同路径有效。 cookie1 的 path 为/b/，而 cookie2 的 path 为/b/c/，则在 a.com/b 页面时只可以访问 cookie1，在 a.com/b/c 页面时，可访问 cookie1 和 cookie2。path 以/结尾
   - 一个 4~8KB，每个域名下是几十~几百 KB，超出无法存储或删除部分
   - 容易受到 CSRF，用户跨站请求会自动携带用户目标网站信息，比如 cookie。
     - 可以后端设置 cookie 的 httpOnly 为 true 防止 js 操作 cookie，防止 xxs
   - 主要用于跟踪用户会话，存储用户偏好设置以及实现永久登陆等功能。

# js 获取 DOM 为什么很慢

DOM 结构身上有很多属性，一个 div 身上就有很多属性。
js 操作 DOM 的引擎线程和 html 的渲染线程是互斥的。使用 js 代码修改 DOM 过多会导致线程频繁切换，带来性能消耗。

# fetch 请求发送多次

在使用 Fetch API 进行网络请求时，可能会出现请求被发送两次的情况，主要原因可能包括：

重定向：如果服务器对请求进行了重定向，浏览器会自动跟随重定向，并发送第二个请求。这通常是因为服务器返回了一个 3xx 的状态码，指示浏览器重定向到另一个 URL。

CORS 预检请求：当使用 Fetch API 发送跨域请求时，如果请求包含某些非简单的内容类型（例如使用了自定义头部），浏览器会发送一个预检请求（OPTIONS 请求）以确认服务器是否允许跨域请求。在预检请求之后，才会发送实际的请求。因此，实际请求可能会出现两次。

        以下情况会触发浏览器不会发送预检请求：

        使用了某些非简单请求方法，例如 get,post,head 等。
        请求头的content-type为
            text/plain
            multipart/form-data
            application/x-www-form-urlencoded

浏览器缓存机制：有时浏览器可能会自动发起一次条件性的请求，以确认资源是否已被修改。这通常发生在缓存策略为“协商缓存”（例如，使用 ETag 或 Last-Modified）时。

代码逻辑错误：在代码中可能存在逻辑错误，导致发送了多个请求。这可能是由于事件处理程序多次触发、定时器多次执行或其他因素引起的。

# 取消浏览器发送的请求

1. AbortController

# get 和 post 请求

1. get 只能传递 ASCII 数据，非 ASCII 需要编码
2. 浏览器发送 GET 不会携带请求体
3. get 请求的地址可以保存为书签
4. 大部分 get 请求传递的数据会携带在 path，分享地址可以重现页面，容易暴露数据
5. 页面数据由 post 提供的话，刷新页面浏览器会提示重新提交
6. get 只能传输少量数据，post 传输数据量无限制
