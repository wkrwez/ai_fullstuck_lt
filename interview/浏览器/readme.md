# 浏览器获取到服务端资源后
- 解析HTML资源生成DOM树
    1. 浏览器接收到的是二进制的字节数据，浏览器会将这些二进制的数据转换成字符串
    2. 对字符串进行词法分析

- 解析css资源生成CSSOM树
- 合并DOM树和CSS树，生成render树
    1. 只会包含需要显示的节点
    2. 根据渲染树来布局页面（回流）
    3. GPU绘制，合成图层，显示在页面上。（重绘）


# 回流
    修改一个元素的几何属性会导致回流，
    1. 修改宽高
    2. 页面初次渲染
    3. 添加，删除元素
    4. 改变窗口大小
# 重绘
外观发生改变
字体大小，
颜色

# 浏览器的优化策略
    当我们修改一个元素的几何属性导致浏览器需要回流时，浏览器会维护一个渲染队列，将需要回流的操作存入队列中，等到后续没有回流行为或者达到阈值时，会一次性将队列中的行为全部执行。
    
offsetxxx
clientxxx
会导致渲染队列强制刷新
# 强缓存
- 设置响应头
Cache-control:'max-age=多少秒'

- 通过浏览器url地址栏发送的get请求，无法被强缓存

- 后端资源修改了，前端无法实时拿到最新资源（通常文件名都携带一串hash值，只要资源被修改，hash值就改变了，也就是文件名被修改了，那么浏览器一定会重新请求。）

# 协商缓存
- 设置响应头
Last-Modified: stats.mtimeMs  //时间戳

浏览器就会自动在请求头中携带if-modified-since,且值为响应头返回的值，当后端判断前端携带



浏览器的缓存机制主要分为强缓存和协商缓存，它们可以帮助减少网络请求，加快页面加载速度，并减轻服务器的负载。

# 强缓存：

强缓存是指浏览器在请求资源时，先检查本地缓存是否存在有效的缓存副本，如果存在且未过期，则直接使用缓存副本，不会向服务器发送请求。
强缓存通过设置 HTTP 响应头来实现，常见的头部字段有：
Cache-Control：通过设置 max-age 指令来定义资源的有效期，单位为秒。
Expires：指定资源的过期时间，是一个绝对时间，服务器返回的时间应当是 GMT 格式的时间字符串。
浏览器在发起请求前会先检查缓存的有效期，如果缓存尚未过期，则直接从缓存中获取资源，不会发起网络请求。
# 协商缓存：

当资源的强缓存失效时，浏览器会向服务器发送请求，服务器会根据请求头中的一些字段来判断资源是否发生了变化。
如果资源未发生变化，则服务器返回 304 Not Modified 状态码，并在响应头中包含一些信息，告诉浏览器可以使用本地缓存。
协商缓存的实现依赖于以下几个头部字段：
Last-Modified：指定资源的最后修改时间。
ETag：资源的唯一标识符，通常是资源内容的哈希值或者其他生成的唯一字符串。(请求时会携带上次请求生成的ETag和服务器的对比，相同则返回304)
当浏览器再次请求资源时，会在请求头中带上 If-Modified-Since 或 If-None-Match 字段，告诉服务器上次请求的资源是什么时候或者是什么标识符。
服务器收到请求后，根据这些字段来判断资源是否发生了变化，如果未发生变化，则返回 304 状态码，告知浏览器直接使用本地缓存。


# 强缓存失效
强缓存可能会失效的原因主要包括以下几点：

缓存过期时间到期: 强缓存是通过设置资源的过期时间或最大缓存时间来控制的。当资源的过期时间到期或者超过了最大缓存时间，浏览器会认为缓存已经失效，需要重新向服务器发起请求获取最新的资源。

用户手动刷新页面: 当用户手动刷新页面时，浏览器会忽略强缓存，而直接向服务器请求最新的资源，以确保用户能够获取到最新的内容。

清除浏览器缓存: 如果用户手动清除了浏览器的缓存数据，或者通过浏览器设置将缓存清除，那么之前存储的所有缓存都会被清除，导致强缓存失效。

特定的缓存控制头: 有时服务器可能发送一些特定的缓存控制头，如 Cache-Control: no-cache 或 Cache-Control: no-store，这些头会指示浏览器不要使用强缓存，而直接向服务器请求资源。

资源被修改: 如果服务器端的资源发生了变化，比如内容更新或者被删除重建，那么强缓存也会失效。服务器会发送新的缓存控制头，告诉浏览器需要重新获取资源。



# 15.浏览器垃圾回收机制
1. 手动回收
2. 自动回收

## 代际假说
 1. 大部分的对象在内存中存在的时间是很短的
 2. 不死的对象，会活得更久 
 3. 
## 分代收集


- 标记-清除：这是最常见的垃圾回收算法之一。它通过标记所有活跃对象，然后清除未标记的对象来进行垃圾回收。这个过程会导致一些停顿，因为在标记和清除阶段，浏览器可能需要暂停页面的执行。(整理内存)
    递归一个对象，当所有的属性都不被使用就认为是垃圾数据。

- 引用计数：这种方法通过记录每个对象被引用的次数来进行垃圾回收。当一个对象的引用次数变为零时，就可以被回收。然而，引用计数法难以处理循环引用的情况，并且可能导致内存泄漏。

- 标记-整理：这种算法首先标记所有活跃对象，然后将它们向一端移动，清理掉另一端的垃圾对象，从而实现内存空间的整理和压缩。

- 增量式垃圾回收：这种方法将整个垃圾回收过程分解成多个小步骤，每一步都会执行一部分垃圾回收工作，从而减少单次回收所带来的停顿时间。

# 16.v8
- 堆被分为新生代区和老生代区
    - 新生代区：副垃圾回收器
    - 老生代区：主垃圾回收器

- 垃圾回收器的工作流程：（联想清理堆）
1. 标记空间中的活动对象和非活动对象（活动对象：还在使用的对象。非活动对象：要被回收的对象）
2. 回收非活动对象的空间
3. 整理内存碎片。

- 副垃圾回收器：
将新生代分成对象空间和空闲空间。对象空间用于存放新进的小对象，当存满后执行回收处理，再将存活的对象复制到空闲空间，此时就做好了内存整理，再反转对象空间和空闲空间。新对象空间继续接收对象（两次回收仍存活的对象会晋升到老生代区）
- 主垃圾回收器
因为存放的对象都比较大，所以适合用副垃圾回收器相同的的算法，只能采用标记清除法，递归一个对象，当对象中任何一个属性都没被使用，则作为垃圾回收掉，再整理空间。

## 全停顿
- js运行在v8的主线程上，当垃圾回收机制生效时，js的执行要让出线程，那么js执行就会暂停
- 采用增量标记法来将垃圾回收过程中的标记过程分成很多个小任务，和js执行来回切换执行。


# js与html
js会阻塞html的解析和渲染，解析完成等待js执行再渲染。

阻塞渲染：如果 JavaScript 代码位于 <script> 标签中，并且位于 HTML 页面的 <head> 部分或者在页面内容中的任何位置，浏览器会在执行 JavaScript 代码之前停止解析 HTML，并等待 JavaScript 代码执行完成后再继续解析和渲染页面。这会导致页面的渲染被延迟，直到 JavaScript 代码执行完毕。

非阻塞渲染：为了避免 JavaScript 代码阻塞页面渲染，可以采取一些措施，例如将 JavaScript 代码放在 HTML 页面的底部，或者使用异步加载 JavaScript 的方式（例如使用 <script async> 或者通过 JavaScript 异步加载技术）。这样浏览器在加载和解析 HTML 页面时不会因为 JavaScript 而停止，可以继续渲染页面的其余部分，同时 JavaScript 代码在后台加载和执行。


# js加载执行会阻塞html的渲染
1. 在script标签上加async，该js加载就不会阻塞html的解析渲染，加载完开始执行js还是会阻止解析和渲染。
2. 在script标签上加defer，该js加载就不会阻塞html的解析渲染，加载完会等html加载完执行js（页面完全渲染完前，DOMContentLoaded[当浏览器解析 HTML 文档并构建了 DOM 树,图片，样式表加载前] 事件触发前才执行）。


# 浏览器三个存储
共同点：都会受到同源策略的影响，协议：域名：端口

1. local和session不能在不同域名下通信，可以使用postMessage API或者跨域共享sessionStorage的第三方库来实现
2. cookie不能在不同域名下通信，可以通过设置cookie的domain和path属性为相同来实现
- domain的设置对子域生效，如domain设置为.a.com，则b.a.com和c.a.com均可使用该cookie
- path不同，cookie1的path为/b/，而cookie2的path为/b/c/，则在a.com/b页面时只可以访问cookie1，在a.com/b/c页面时，可访问cookie1和cookie2。path以/结尾

