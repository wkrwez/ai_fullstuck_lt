# HTTP 超文本传输协议 /0.9

- 基于 TCP
- 只有请求行 发送 GET/响应整个 index.html
- 以 ASCII 字符流的编码方式进行传输
- 0.9 的缺点：只支持 html 一种类型的资源传输

# HTTP /1.0

升级后就有了 js，css，图片，音频...
支持状态码，多种请求方式，持久连接

- 请求头
  accept：text/html
  accept-encoding：gzip deflate br;
  accept-language：zh-CN

- 响应头
  content-type：text/html
  accept-encoding：br；

- 为了传输不同的类型资源而诞生

# HTTP /1.1

- 持久连接，减轻了服务器的负担

- 同时最多维护 6 个持久连接

- 建立长连接导致队头阻塞
- 请求发送完整头部信息

1. 前一个 http 请求没有得到响应，后一个 http 请求无法发送

- HOST 头部
  必须，使一个服务器托管多个域名

- 响应头：
  1.0 Content-Length:1024

  后端动态内容生成，无法确定数据大小

  1.1 Chunk transfer 机制：将资源文件处理成若干个数据块并编辑数据块的大小，最后发送一个标记为 0 的数据块来告诉客户端，资源传输完成。

# HTTP /2.0

- 1.1 缺点:

  1. 队头堵塞
  2. 带宽利用率低
     (1)同时开启多条持久连接,相互之间会竞争带宽
     (2)TCP 的慢启动拖延了首页首次渲染的时间
     (3)队头阻塞 (前一个 http 请求被阻塞 5s,后一个 http 请求又不能发送,那么该 5s 内带宽白白浪费)

- 一次只能维护一个 TCP 长连接
- 头部使用压缩算法 HPACK
- 支持客户端请求前推送资源

- 多路复用(解决请求层面的队头阻塞，但是 tcp 层面还是存在，tcp 包丢失一个，整个流都受到影响，直到该包重新传输)
  将每一个请求处理成一帧一帧的请求片段(二进制分帧层),并给每一帧打上标记,服务端接收到所有的帧之后,会将标记相同的帧合并为一个完整请求,再响应该请求,响应体同样处理成一帧一帧传输

# HTTPS HTTP + TLS(加密协议)

- 对称加密：
  双方都要拥有相同的密钥，密钥用于数据的加密和解密，如何让双方都具有相同的密钥就变成了一个问题
  使用网络传输，一旦在传输密钥的阶段被截获，接下来的加密就没有意义

- 非对称加密：
  首先服务端创建公钥和私钥，并将公钥发布出去，那么客户端也就知道了公钥，客户端创建一个密钥，
  通过公钥加密将密钥传给服务端，服务端通过独有的私钥进行解密得到正确的密钥。

先用非对称加密让客户端和服务端具有相同的密钥，然后再进行对称加密

# HTTP /3.0

2.0 的缺点

1.  TCP 队头阻塞：当存在数据包丢失时，TCP 会重传一个新的包，在新包传递前，后续的数据包会被暂停传输
2.  TCP 握手也是时间开销

- TCP 协议僵化

- 改 UDP ---QUIC 协议（基于 UDP）
  1. 在 UDP 上实现了 TCP 的拥塞控制，可靠性传输 （拥塞控制：网络拥塞就降低发送速率）
  2. 集成了 TLS 加密
  3. 实现了多路复用：单个连接发送多个请求
  4. 快速握手

# js 获取 DOM 为什么很慢

DOM 结构身上有很多属性，一个 div 身上就有很多属性。
js 操作 DOM 的引擎线程和 html 的渲染线程是互斥的。使用 js 代码修改 DOM 过多会导致线程频繁切换，带来性能消耗。

# fetch 请求发送多次

在使用 Fetch API 进行网络请求时，可能会出现请求被发送两次的情况，主要原因可能包括：

重定向：如果服务器对请求进行了重定向，浏览器会自动跟随重定向，并发送第二个请求。这通常是因为服务器返回了一个 3xx 的状态码，指示浏览器重定向到另一个 URL。

CORS 预检请求：当使用 Fetch API 发送跨域请求时，如果请求包含某些非简单的内容类型（例如使用了自定义头部），浏览器会发送一个预检请求（OPTIONS 请求）以确认服务器是否允许跨域请求。在预检请求之后，才会发送实际的请求。因此，实际请求可能会出现两次。

浏览器缓存机制：有时浏览器可能会自动发起一次条件性的请求，以确认资源是否已被修改。这通常发生在缓存策略为“协商缓存”（例如，使用 ETag 或 Last-Modified）时。

代码逻辑错误：在代码中可能存在逻辑错误，导致发送了多个请求。这可能是由于事件处理程序多次触发、定时器多次执行或其他因素引起的。
