# HTTP 超文本传输协议 /0.9
- 基于TCP
- 只有请求行    GET/index.html
- 以 ASCII 字符流的编码方式进行传输

# HTTP  /1.0
- 0.9的缺点：只支持html一种类型的资源传输

升级后就有了js，css，图片，音频...

- 请求头
    accept：text/html
    accept-encoding：gzip deflate br;
    accept-language：zh-CN

- 响应头
    content-type：text/html
    accept-encoding：br；

- 为了传输不同的类型资源而诞生


# HTTP  /1.1
- 持久连接，减轻了服务器的负担

- 同时最多维护6个持久连接

- 建立长连接导致队头阻塞
1. 前一个http请求没有得到响应，后一个http请求无法发送

- HOST

- 响应头：
    1.0  Content-Length:1024

    后端动态内容生成，无法确定数据大小

    1.1 Chunk transfer机制：将资源文件处理成若干个数据块并编辑数据块的大小，最后发送一个标记为0的数据块来告诉客户端，资源传输完成。


# HTTP /2.0
- 1.1 缺点:
    1. 队头堵塞
    2. 带宽利用率低
        (1)同时开启多条持久连接,相互之间会竞争带宽
        (2)TCP的慢启动拖延了首页首次渲染的时间
        (3)队头阻塞 (前一个http请求被阻塞5s,后一个http请求又不能发送,那么该5s内带宽白白浪费)

- 一次只能维护一个TCP长连接


- 多路复用(解决队头阻塞)
    将每一个请求处理成一帧一帧的请求片段(二进制分帧层),并给每一帧打上标记,服务端接收到所有的帧之后,会将标记相同的帧合并为一个完整请求,再响应该请求,响应体同样处理成一帧一帧传输

# HTTPS HTTP + TLS(加密协议)
   
- 对称加密：
    双方都要拥有相同的密钥，密钥用于数据的加密和解密，如何让双方都具有相同的密钥就变成了一个问题
    使用网络传输，一旦在传输密钥的阶段被截获，接下来的加密就没有意义

- 非对称加密：
    首先服务端创建公钥和私钥，并将公钥发布出去，那么客户端也就知道了公钥，客户端创建一个密钥，
    通过公钥加密将密钥传给服务端，服务端通过独有的私钥进行解密得到正确的密钥。

先用非对称加密让客户端和服务端具有相同的密钥，然后再进行对称加密


# HTTP /3.0
  2.0的缺点
   1. TCP队头阻塞：当存在数据包丢失时，TCP会重传一个新的包，在新包传递前，后续的数据包会被暂停传输
   2. TCP握手也是时间开销

- TCP协议僵化

- 改UDP ---QUIC协议
    1. 在UDP上实现了TCP的拥塞控制，可靠性传输
    2. 集成了TLS加密
    3. 实现了多路复用
    4. 快速握手

# 浏览器获取到服务端资源后
- 解析HTML资源生成DOM树
    1. 浏览器接收到的是二进制的字节数据，浏览器会将这些二进制的数据转换成字符串
    2. 对字符串进行词法分析

- 解析css资源生成CSSOM树
- 合并DOM树和CSS树，生成render树
    1. 只会包含需要显示的节点
    2. 根据渲染树来布局页面（回流）
    3. GPU绘制，合成图层，显示在页面上。（重绘）


# 回流
    修改一个元素的几何属性会导致回流
    1. 修改宽高
    2. 页面初次渲染
    3. 添加，删除元素
    4. 改变窗口大小
# 重绘

# 浏览器的优化策略
    当我们修改一个元素的几何属性导致浏览器需要回流时，浏览器会维护一个渲染队列，将需要回流的操作存入队列中，等到后续没有回流行为或者达到阈值时，会一次性将队列中的行为全部执行。
    
offsetxxx
clientxxx
会导致渲染队列强制刷新

# js加载执行会阻塞html的渲染
1. 在script标签上加async，该js加载就不会阻塞html的渲染，加载完开始执行js还是会阻止。
2. 在script标签上加defer，该js加载就不会阻塞html的渲染，加载完会等html加载完执行js。

# js获取DOM为什么很慢
DOM结构身上有很多属性，一个div身上就有很多属性。
js操作DOM的引擎线程和html的渲染线程是互斥的。使用js代码修改DOM过多会导致线程频繁切换，带来性能消耗。