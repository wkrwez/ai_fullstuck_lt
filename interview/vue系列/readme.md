# 1.说说你对vue的理解
- 是什么
    是一个js框架，用于创建一个单页应用的web应用框架，主旨是为了简化web的开发，主要靠MVVM的驱动方式来实现视图的更新。

- 特性
    1. MVVM (Model - View - ViewModel)
        1.1. Model--模型层：模板，业务逻辑的代码
        1.2. View--视图层：html页面
        1.3. ViewModel--视图模型层（用于将模型和视图进行连接通信）
    2. 组件化
        1. 代码复用
        2. 降低整体的耦合度

    3. 指令
        1. 大大减少了手动操作DOM的代码


# 2.说说你对SPA的理解
- 是什么
    只有一个html页面，本质上只需要控制某一个代码片段被拿到该html中生效而已。
- 特点
    页面在任何时候都不会重新加载，不会打断用户体验。
    存在首屏加载时间过长的情况
    不利于SEO搜索引擎的抓取。用服务端渲染ssr

- 解决首屏加载过慢的手段
    1. 路由懒加载
    2. ssr:服务端渲染，在vue项目中再启动一个node服务，负责直接响应首页的代码片段，项目其他的代码依然保持原有的加载方式。这样就能让用户第一时间看到首页


# 3. 说说你对双向绑定的理解
- 是什么
    模板层的数据变更会导致视图层的更新。视图层的数据更新也会导致模板层的数据改变

- 原理 （ViewModel 的原理）
    1. 监听器：对所有的数据进行监听
    2. 解析器：对每个元素节点的指令进行解析

- 双向绑定的原理
1. vue的数据源会被劫持，在劫持的过程中为属性做依赖收集，vue中的观察者Watcher负责更新视图，依赖收集到的是观察者Watcher的实例对象。当属性值发生变更时会触发依赖，进而触发视图更新函数。
2. 在数据劫持的同时，vue会编译模板，解析指令，当视图层的数据发生变更时，编译器中绑定的函数会被触发，进而获取到最新的数据值，再次通知Watcher去触发依赖。


# 4.vue2 和 vue3的区别
- 选项式API和组合式API
      - this不需要，拥抱函数式编程
      - 代码量大的话 data + methods + getters 相关的逻辑需要搬来搬去
      - 组合式 可以让 reactive/ref + method（逻辑） + onMounted（生命周期） 以业务为单位在一起
   - 响应式原理
      - vue2 defineProperty （一次性代理完） 数组会有缺点（无法监听索引变化，无法拦截数组方法）
      - vue3 reactive 用的是Proxy，有13种拦截方法 性能更好（懒代理:在访问对象属性时并不会立即触发代理的拦截操作，而是等到真正需要对属性进行操作时才会触发拦截器。拦截更精确，减小性能开销）
      - ref 面向对象的get set
         因为核心就是 拦截 + track(get) + trigger(set) + effect

      - WeakMap理解
         依赖关系收集是靠全局的唯一的weakmap，以响应式对象为key，再是它的一些属性，proxy支持对对象的整体代理，可以一次性代理，值就是用track收集的函数数组（effects），全部执行。
         - 为什么用weakmap
            组件有很多，响应式数据很多，路由组件很多，
            当组件下线，路由切换了，有些响应式不用维护了，weakmap会在响应式对象被垃圾回收后自动删除相应的项。

   - v-if 和 v-for 优先级
      - v-if优先级高 vue3修正了bug  
         - v-if为false 没必要 v-for渲染


# 5.vue为什么不建议使用index作为key?

- 虚拟DOM
    1. 虚拟DOM是vue中的编译器将模板代码编译成对象
- diff
    1. 将新老VDOM的不同点找到并生成一个补丁

    - 过程:
    1. 同层比较,是不是相同节点,不相同直接废弃老DOM
    2. 是相同点节点,比较节点上的属性,产生一个补丁包
    3. 继续比较下一层的子节点,采用双端队列的方式,尽量复用,产生一个补丁包
    4. 同上
- 为什么要有key?
    让diff比较的效率更高

- 为什么不能用index?
因为index是数组下标,下标永远是固定的从0开始,哪怕数据只是发生了位置变更,key就会不一样,这就会导致原本可以复用的节点被认定为不可复用,导致重新渲染,浪费渲染性能

- 可不可以用随机数作为key
每次数据更新,生成的key是不一样的,导致每次都会重新渲染,浪费渲染性能

# 6. 生命周期
- onMounted() DOM挂载后执行（mount('#app')挂载）,渲染前
- onUpdated() DOM更新后执行，父组件在子组件后执行钩子函数
- onUnmounted() 组件被卸载后调用，可以清除定时器，事件监听和接口请求，服务端渲染期间不调用
- onBeforeMounted() 在组件被挂载前调用
- onBeforeUpdata() 在组件因为响应式数据更新而更新其DOM树前调用
- onBeforeUnmount() 在组件卸载前调用
- onErrorCaptured() 捕捉了后代组件传递的错误时调用
- onRenderTracked() 当组件渲染过程中追踪到响应式依赖时调用
- onRenderTriggered()  当响应式依赖更新触发组件渲染后调用
- onServerPrefetch() 异步函数，在组件实例在服务器上被渲染之前调用


# 7. 聊聊组件通信 (子组件不能修改父组件的数据，只能传过去让父组件修改)
1. 父子通信 子组件props接收
2. 子父通信 子组件 emit发布一个事件，父组件订阅该事件
3. 子父通信 子组件拿到父组件的数据并修改后emit出来，父组件靠v-model实现双向绑定
    const emits = defineEmits(['update:list'])//update是固定的
4. 子父通信 子组件defineExpose暴露出来值，父组件利用ref读取着整个子组件对象来获取值
5. 父子通信 父组件 provide  子组件  inject
6. EventBus mitt插件
7. vuex || pinia

# 8. 父子组件谁的生命周期先执行
父组件挂载前，子组件挂载前，子组件挂载后，父组件挂载后

# 9. v-for 和 v-if 共存吗？
1. v2中，v-for优先级更高，会报警告，因为性能浪费
2. v3中，v-if优先级更高，没有用到for中的变量是不会报错的

# 10. 什么是虚拟DOM
1. 一个用js对象来描述的DOM结构
2. 当一次操作导致多处DOM更新，不使用虚拟DOM，浏览器需要重新一个一个构建DOM树，导致多次渲染。
    但是少量DOM更新，diff算法同样会存在性能开销。
3. 跨平台

# 11. 说说diff
- 同层比较
- 深度优先
pathVnode步骤：
1. 判断节点是不是文本，是的话直接更新文本
2. 比较节点类型，属性是否相同，不同则直接替换
3. 比较子节点，不断生成补丁包

- 双端队列
    提升比较的效率

# 12. vue中的修饰符


# 13. vue2 和 vue3 的区别
1. 速度更快：
    - 虚拟DOM实现的函数被重写，效率提升。
    - 编译模板的优化
2. 体积减小：
    - tree-shaking更彻底:剔除类似于打印命令这种无用代码
3. 更易维护
    - 函数式编程
    - 更好的TS支持

4. 更接近原生语法
    - 

5. v3 template 模板中支持多个节点

6. teleport 组件

7. 响应式区别
