1. input 框上传文件
2. 利用 Blob 自带的 slice 方法对文件切片（自己设定文件切片的大小）
3. 对需要传给后端的文件信息进行包装，加上百分比用来显示进度。（每个文件大小，名字编号，百分比）
4. 把切片转换成 formData 表单数据流，这是二进制打印看不到数据
5. 遍历这些切片，每一个都是一个 http 请求。

- 把切片转成表单数据流,Blob 是 js 的，将 Blob 传给后端可能看不懂，所以转成表单

- formData 是一个用于在客户端创建 HTML 表单数据的 JavaScript 对象。它提供了一种简单的方式来构建包含键值对的表单数据，可以用于通过 AJAX 或 Fetch API 将数据发送到服务器。

form 表单会自动刷新

# 前端

1. 前端获取到大文件，浏览器会默认即将文件读取成 Blob 对象类型
2. 借助 Blob 自带的 slice 方法，将文件切割处理成很多个小文件
3. 将所有的小文件转换成 formData 类型，再向后端传输

# 后端

1. 接收到前端传递的文件片段，借助 multiparty 来解析表单类型的数据
2. 将解析出来的文件片段存入本地文件夹中(不能刚拿到几个就合并，顺序可能不一样)
3. 后端合并切片
   1. 前端最后传递一个空的切片，每一个切片都是 http 请求，可能空的会先到，所以不行。
   2. 每个切片中记录总的切片个数
   - 排序所有的切片
   - 创建一个可以写入流类型的文件
   - 将每一个片段读成流类型，再写入到可写流中

# 问题

1. 前端传给后端切片，后端并没有拿到全部切片会是什么原因？请解决

- 问题
  1. 网络问题
  2. 前端代码问题，服务端配置问题
  3. 并发问题，服务端处理逻辑不健全
- 解决
  1. 前端断点续传，在中断处继续上传
  2. 服务端校验切片完整性

2. 转成流类型时得创建一个新的文件夹

3. 切片上传中断如何重新上传
   上传中断接收一个请求错误，先修改上传状态。
   - 使用 map 存储文件已经上传成功的片段的标识符 chunkIndex，点击重新上传后获取的 input 的文件，重新执行切片请求函数，如果 map 中的 chunkIndex 并未存储则重新请求这一片段
   - 使用 Promise.allSettle() 可以在全部请求完成后拿到 status 判断是否成功，使用 map 存储请求结果 chunkIndex，进而重新请求

#

将文件切成一定数量的片段，控制每一并发的片数，当有一个片上传成功就再上传后续片段，有一个失败就重新上传，失败超过两次则放弃上传。当所有的片段都上传过了，如果全部成功则上传成功，如果存在片段失败两次，就需要触发重新上传
